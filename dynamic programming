####### Given a list of weights [w1,w2,...,wn], determine all sums that can be constructed using the weights.
#include <iostream>

using namespace std;

int main() {
    int n = 4;
    int W = 12;
    int w[5] = {0,1,3,3,5};
    bool possible[12] = {false};
    possible[0] = true;
    for (int k = 1; k <= n; k++) {
        for (int x = W; x >= 0; x--) {
            if (possible[x]) {
                possible[x+w[k]] = true;
            }
        }
    }
    for (int l = 0; l <= 12; l++) {
        printf("%s-%d\n", possible[l] ? "true":"false",l);
    }
    return 0;
}

#######Largest possible path: The sum of the values on the path is 67, and this is the largest possible sum on a path from the upper-left corner to the lower-right corner.
int sum[N][N];
and calculate the sums as follows:
for (int y = 1; y <= n; y++) {
for (int x = 1; x <= n; x++) {
sum[y][x] = max(sum[y][x-1],sum[y-1][x])+value[y][x];
}
}

######Longest increasing subsequence
for (int k = 0; k < n; k++) {
length[k] = 1;
for (int i = 0; i < k; i++) {
if (array[i] < array[k]) {
length[k] = max(length[k],length[i]+1);
}
}
}

#########Counting the number of solutions
олькими способами можно разменять сумму x монетами заданных номиналов. Например, если coins = {1, 3, 4} и x = 5, то всего есть 6 способов:
• 1 + 1 + 1 + 1 + 1; • 3 + 1 + 1;
• 1 + 1 + 3; • 1 + 4;
• 1 + 3 + 1; • 4 + 1

#include <iostream>
#include <vector>

using namespace std;

long long dp[1000001];
const int MOD = (int) 1e9 + 7;

int main() {
    int n, x; cin >> n >> x;
    vector<int> coins(n);
    for (int i = 0; i < n; i++) {
        cin >> coins[i];
    }
    dp[0] = 1;
    for (int weight = 0; weight <= x; weight++) {
        for (int i = 1; i <= n; i++) {
            if(weight - coins[i - 1] >= 0) {
                dp[weight] += dp[weight - coins[i - 1]];
                dp[weight] %= MOD;
            }
        }
    }
    cout << dp[x] << '\n';

    return 0;
}

#########Пусть имеется множество номиналов монет coins = {c1, c2, …, ck} и денежная сумма n. Задача заключается в том, чтобы разменять сумму n, исполь-зовав как можно
меньше монет. Количество монет одного номинала не ограничено. Например, если coins = {1, 2, 5} и n = 12, то оптимальное решение 5 + 5 + 2 = 12, так что достаточно трех монет

int solve(int x) {
 if (x < 0) return INF;
 if (x == 0) return 0;
 if (ready[x]) return value[x];
 int best = INF;
 for (auto c : coins) {
 best = min(best, solve(x-c)+1);
 }
 ready[x] = true;
 value[x] = best;
 return best;
}

iteratively,
value[0] = 0;
for (int x = 1; x <= n; x++) {
value[x] = INF;
for (auto c : coins) {
if (x-c >= 0) {
value[x] = min(value[x], value[x-c]+1);
}
}
}
